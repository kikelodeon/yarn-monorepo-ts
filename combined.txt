
=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\.yarnrc.yml ===

nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-berry.js




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\Dockerfile.development ===

# Usa una imagen base de Node (versión LTS recomendada)
FROM node:18-alpine

# (Opcional) Instala herramientas adicionales si las necesitas, por ejemplo git
# RUN apk add --no-cache git

# Establece el directorio de trabajo
WORKDIR /app

# Copia los archivos de configuración del proyecto para aprovechar la caché de dependencias.
# Asegúrate de incluir package.json, yarn.lock, turbo.json, y archivos de configuración de Yarn (por ejemplo, .yarnrc.yml)
COPY package.json yarn.lock turbo.json .yarnrc.yml ./

# Si usas Yarn v4 con PnP y tienes la carpeta .yarn, cópiala también:
COPY .yarn .yarn

# Instala las dependencias
RUN yarn install

# Copia el resto del código (esta capa se regenerará si se modifica el código fuente)
COPY . .

# Expón los puertos que usen tus servicios. Por ejemplo, si tu service-authentication usa el puerto 3000:
EXPOSE 3000

# Define la variable de entorno para el entorno de desarrollo
ENV NODE_ENV=development

# Comando de inicio: Ejecuta la tarea "dev" definida en el package.json raíz (por ejemplo, "turbo run dev")
CMD ["yarn", "dev"]




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\jest.config.ts ===

import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/?(*.)+(spec|test).[tj]s?(x)'], // Match .spec.ts or .test.ts files
  moduleFileExtensions: ['ts', 'js'],
  modulePathIgnorePatterns: ['<rootDir>/dist/', '.*/dist/'], // Ignore all dist folders
  transform: {
    '^.+\\.ts$': 'ts-jest', // Use ts-jest to transform TypeScript files
  },
};

export default config;




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\package.json ===

{
  "name": "kikerepo",
  "private": true,
  "packageManager": "yarn@4.0.2",
  "workspaces": [
    "packages/*/**",
    "services/*"
  ],
  "scripts": {
    "build": "turbo run build",
    "buildasync": "turbo run build --parallel",
    "dev": "turbo run dev",
    "test": "turbo run test",
    "clear": "yarn workspaces foreach --all run clear && rimraf .turbo node_modules",
    "uninstall": "turbo run uninstall && rimraf node_modules",
    "lint": "turbo run lint"
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "@types/node": "^20.4.5",
    "jest": "^29.7.0",
    "rimraf": "^6.0.1",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "turbo": "^2.4.0",
    "typescript": "^5.7.3"
  },
  "dependencies": {
    "@prisma/client": "^6.2.1",
    "argon2": "^0.41.1",
    "inversify": "^6.2.1",
    "prisma": "^6.2.1",
    "reflect-metadata": "^0.2.2"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\tsconfig.json ===

{
  "compilerOptions": {
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "dist",
    "rootDir": ".",
    "module": "CommonJS",
    "target": "ES2020",
    "strict": true,
    "esModuleInterop": true,
    "baseUrl": "."
  },
  "files": [],
  "include": [],
  "references": [
    //Utils
    { "path": "./packages/utils/env" },
    { "path": "./packages/utils/uuid6" },
    //Common
    { "path": "./packages/domain/_common" },
    { "path": "./packages/infrastructure/_common" },
    { "path": "./packages/contracts/_common" },
    { "path": "./packages/application/_common" },
    //User
    { "path": "./packages/domain/user" },
    { "path": "./packages/infrastructure/user" },
    { "path": "./packages/contracts/user" },
    { "path": "./packages/application/user" },
    //Session
  /*  { "path": "./packages/domain/session" },
    { "path": "./packages/infrastructure/session" },
    { "path": "./packages/contracts/session" },
    { "path": "./packages/application/session" },*/
    //Services
    { "path": "./services/service-authentication" },
    //{ "path": "./services/service-mailing" }
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\turbo.json ===

{
  "$schema": "https://turborepo.org/schema.json",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "test": {},
    "clean": {},
    "clear": {},
    "uninstall": {},
    "lint": {}
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\.vscode\launch.json ===

{
  "version": "0.2.0",
  "compounds": [
    {
      "name": "Debug Full Monorepo",
      "configurations": ["Debug Lib", "Debug Service"]
    }
  ],
  "configurations": [
    {
      "name": "Debug Lib",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/packages/lib/dist/index.js", // Point to compiled ESM
      "outFiles": ["${workspaceFolder}/packages/lib/dist/**/*.js"],
      "preLaunchTask": "Build Lib",
      "sourceMaps": true,
      "console": "integratedTerminal",
      "internalConsoleOptions": "openOnSessionStart"
    },
    {
      "name": "Debug Service",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/packages/service-authentication/dist/index.js", // Point to compiled ESM
      "outFiles": ["${workspaceFolder}/packages/service-authentication/dist/**/*.js"],
      "preLaunchTask": "Build Service",
      "sourceMaps": true,
      "console": "integratedTerminal",
      "internalConsoleOptions": "openOnSessionStart"
    }
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\.vscode\tasks.json ===

{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Build Lib",
      "type": "shell",
      "command": "yarn workspace @kikerepo/lib build",
      "group": {
        "kind": "build",
        "isDefault": true
      }
    },
    {
      "label": "Build Service",
      "type": "shell",
      "command": "yarn workspace @kikerepo/service-authentication build",
      "group": {
        "kind": "build",
        "isDefault": true
      }
    }
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\docker\development\.env ===

NODE_ENV=*****
SERVICE_AUTHENTICATION_PORT=*****
SERVICE_MAILING_PORT=*****
SERVICE_REDIS_PORT=*****
SERVICE_REDIS_PASSWORD=*****



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\docker\development\docker-compose.yml ===

services:
  authentication-service:
    build:
      context: ../../
      dockerfile: services/service-authentication/Dockerfile.development
    ports:
      - "${SERVICE_AUTHENTICATION_PORT}:5001"
    volumes:
      - ../../services/service-authentication/src:/app/src
      - authentication_node_modules:/app/node_modules
    env_file:
      - ../../services/service-authentication/.env.development
    command: yarn dev
    depends_on:
      - redis

  mailing-service:
    build:
      context: ../../
      dockerfile: services/service-mailing/Dockerfile.development
    ports:
      - "${SERVICE_MAILING_PORT}:5002"
    volumes:
      - ../../services/service-mailing/src:/app/src
      - mailing_node_modules:/app/node_modules
    env_file:
      - ../../services/service-mailing/.env.development
    command: yarn dev
    depends_on:
      - redis

  redis:
    image: redis:7.0-alpine
    ports:
      - "${SERVICE_REDIS_PORT}:6379"
    volumes:
      - redis-data:/data
    environment:
      - REDIS_PASSWORD=${SERVICE_REDIS_PASSWORD}
    command: redis-server --requirepass ${SERVICE_REDIS_PASSWORD}
    healthcheck:
      test: ["CMD", "redis-cli", "PING"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  authentication_node_modules:
  mailing_node_modules:
  redis-data:




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\docker\production\.env ===





=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\docker\production\docker-compose.yml ===

version: '3.8'

services:
  authentication-service:
    image: your-dockerhub-username/service-authentication:latest
    ports:
      - '3000:3000'
    env_file:
      - ../../services/service-authentication/.env.production
    depends_on:
      - redis
    restart: unless-stopped

  mailing-service:
    image: your-dockerhub-username/service-mailing:latest
    ports:
      - '4000:4000'
    env_file:
      - ../../services/service-mailing/.env.production
    depends_on:
      - redis
    restart: unless-stopped

  redis:
    image: redis:7.0-alpine
    ports:
      - '6379:6379'
    volumes:
      - redis-prod-data:/data
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    command: redis-server --requirepass ${REDIS_PASSWORD}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  redis-prod-data:




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\package.json ===

{
  "name": "@kikerepo/application-user",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "@kikerepo/application-common": "workspace:*",
    "@kikerepo/contracts-common": "workspace:*",
    "@kikerepo/domain-user": "workspace:*",
    "@kikerepo/infrastructure-user": "workspace:*",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "libphonenumber-js": "^1.11.18"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist", // Compiled files go to dist/
    "rootDir": "./src", // Only source files are included
    "composite": true, // Required for project references
    "declaration": true,
    "declarationMap": true,
    "strict": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "skipLibCheck": true,
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "references": [
    { "path": "../_common" } // Uses compiled @kikerepo/domain-common
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\index.ts ===

export * from './commands';
export * from './queries';
export * from './events';
export * from './results';
export * from './validators';
export * from './handlers';
export * from './mappers';
export * from './errors';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\commands\index.ts ===


export * from './RegisterCommand';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\commands\RegisterCommand.ts ===

// src/application/user/commands/RegisterCommand.ts
import { IsEmail, IsString, IsOptional, Length } from 'class-validator';

import { IsStrongPassword,IsPhoneNumber } from '../validators';
import { Email, InputPassword, Phone } from '@kikerepo/domain-user';
export class RegisterCommand {
  @IsEmail()
  email: Email;

  @IsString()
  @IsStrongPassword()
  password: InputPassword;

  @IsOptional()
  @IsString()
  @IsPhoneNumber()
  phone?: Phone;

  constructor(email: Email, password: InputPassword, phone?: Phone) {
    this.email = email;
    this.password = password;
    this.phone = phone;
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\errors\EmailAlreadyInUseError.ts ===

// src/application/user/errors/EmailAlreadyInUseError.ts
import { ConflictError } from '@kikerepo/contracts-common'; // Import the ValidationError from contracts

export class EmailAlreadyInUseError extends ConflictError {
  constructor(email: string) {
    // Create a detailed validation error for the email
    super();
   this.message = 'Email is already in use.';

    // Call the parent constructor to set the message and validation errors

  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\errors\index.ts ===


export { EmailAlreadyInUseError } from './EmailAlreadyInUseError';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\events\index.ts ===


export * from './UserLoggedInEvent';
export * from './UserRegisteredEvent';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\events\UserLoggedInEvent.ts ===

export class UserLoggedInEvent {
    constructor(public readonly userId: string, public readonly timestamp: Date) {}
  }
  



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\events\UserRegisteredEvent.ts ===

export class UserRegisteredEvent {
    constructor(
      public readonly userId: string,
      public readonly email: string,
      public readonly timestamp: Date
    ) {}
  }
  



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\handlers\index.ts ===

// src/shared/validation/index.ts
export { LoginQueryHandler } from './LoginQueryHandler';
export { RegisterCommandHandler,RegisterCommandHandlerToken } from './RegisterCommandHandler';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\handlers\LoginQueryHandler.ts ===


export class LoginQueryHandler {
  
  }
  



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\handlers\RegisterCommandHandler.ts ===

import { injectable, inject } from 'inversify';
import { IUserRepository, IUserRepositoryToken, IHashingService, IHashingServiceToken } from '@kikerepo/domain-user';
import { User } from '@kikerepo/domain-user';
import { EmailAlreadyInUseError } from '../errors';
import { RegisterCommand } from '../commands/RegisterCommand';
import { RegisterResult } from '../results/RegisterResult';
import { logger } from '@kikerepo/infrastructure-common'; // <--- Importa tu logger
export const RegisterCommandHandlerToken = Symbol('RegisterCommandHandlerToken');

@injectable()
export class RegisterCommandHandler {
  constructor(
    @inject(IUserRepositoryToken) private userRepository: IUserRepository,
    @inject(IHashingServiceToken) private hashingService: IHashingService
  ) {}

  public async handle(command: RegisterCommand): Promise<RegisterResult | Error> {
    logger.info('[RegisterCommandHandler] Handling register command', { email: command.email.value });

    const existingUser = await this.userRepository.findByEmail(command.email.value);
    if (existingUser) {
      logger.warn('[RegisterCommandHandler] Email already in use', { email: command.email.value });
      return new EmailAlreadyInUseError(command.email.value);
    }

    const hashedpassword = await this.hashingService.hash(command.password);
    const user = User.createUnique(command.email, hashedpassword, command.phone);
    await this.userRepository.save(user);

    logger.info('[RegisterCommandHandler] User registered successfully', { userId: user.id.value });
    return new RegisterResult(user.id, user.email);
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\mappers\index.ts ===

// src/shared/validation/index.ts
export { RegisterResultToRegisterResponseMapper } from './RegisterResultToRegisterResponseMapper';
export { RegisterRequestToRegisterCommandMapper } from './RegisterRequestToRegisterCommandMapper';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\mappers\RegisterRequestToRegisterCommandMapper.ts ===

import { RegisterRequest } from '@kikerepo/contracts-user';
import { RegisterCommand } from '../commands';
import { Email, InputPassword, Phone } from '@kikerepo/domain-user';

export class RegisterRequestToRegisterCommandMapper {
  static toCommand(dto: RegisterRequest): RegisterCommand {
    const emailVO = new Email(dto.email);
    const passwordVO = new InputPassword(dto.password);
    const phoneVO = dto.phone ? new Phone(dto.phone) : undefined;
    return new RegisterCommand(emailVO, passwordVO, phoneVO);
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\mappers\RegisterResultToRegisterResponseMapper.ts ===

// src/application/user/mappers/UserRegisterResultToResponseMapper.ts
import { RegisterResult as RegisterResult } from '../results/RegisterResult';  // Assuming this is the result class
import { RegisterResponse } from '@kikerepo/contracts-user';   // Assuming this is the response DTO

export class RegisterResultToRegisterResponseMapper {
  static toResponse(result: RegisterResult): RegisterResponse {
    // Map UserRegisterResult to UserRegisterResponse
    return new RegisterResponse(
      result.userId.value, // Convert UserId (value object) to string
      result.email.value          // Directly pass email as it’s a simple value
    );
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\queries\index.ts ===

export * from './LoginQuery';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\queries\LoginQuery.ts ===

// src/application/queries/LoginQuery.ts

import { IsEmail, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { Email,InputPassword } from "@kikerepo/domain-user";
import { IsStrongPassword } from '../validators';

/**
 * Represents a login query in the CQRS pattern.
 */
export class LoginQuery {
  @IsEmail()
  @ValidateNested()
  @Type(() => Email)
  public readonly email: Email;

  @IsStrongPassword()
  @ValidateNested()
  @Type(() => InputPassword)
  public readonly password: InputPassword;

  constructor(email: Email, password: InputPassword) {
    this.email = email;
    this.password = password;
  }
}



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\results\index.ts ===

export * from './LoginResult';
export * from './RegisterResult';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\results\LoginResult.ts ===

export class LoginResult {
    constructor(
      public readonly userId?: string,
      public readonly token?: string
    ) {}
  }
  



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\results\RegisterResult.ts ===

import { UserId,Email } from "@kikerepo/domain-user";

export class RegisterResult {
  userId: UserId;
  email: Email;

  constructor(userId: UserId, email: Email) {
    this.userId = userId;
    this.email = email;
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\validators\index.ts ===

// src/shared/validation/index.ts
export { IsStrongPassword } from './IsStrongPassword';
export { IsPhoneNumberCustom as IsPhoneNumber } from './IsPhoneNumber';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\validators\IsPhoneNumber.ts ===

// src/shared/validation/decorators/IsPhoneNumber.ts
import {
  registerDecorator,
  ValidationOptions,
  ValidationArguments,
} from 'class-validator';
import { parsePhoneNumberFromString } from 'libphonenumber-js';

/**
 * Custom decorator to validate phone numbers, automatically extracting the country code.
 * @param validationOptions - Optional validation options.
 */
export function IsPhoneNumberCustom(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isPhoneNumberCustom',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        /**
         * Validates the phone number by parsing it and automatically detecting the country code.
         * @param value - The phone number string to validate.
         * @param args - Validation arguments.
         * @returns `true` if the phone number is valid, otherwise `false`.
         */
        validate(value: any, args: ValidationArguments) {
          if (typeof value !== 'string') return false;

          // Parse the phone number and automatically detect the country code
          const phoneNumber = parsePhoneNumberFromString(value);

          // Ensure phone number is valid
          return phoneNumber ? phoneNumber.isValid() : false;
        },

        /**
         * Default error message when the phone number is invalid.
         * @param args - The validation arguments.
         * @returns A message indicating the validation failure.
         */
        defaultMessage(args: ValidationArguments) {
          return `${args.property} must be a valid phone number.`;
        },
      },
    });
  };
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\user\src\validators\IsStrongPassword.ts ===

// src/shared/validation/decorators/IsStrongPassword.ts
import {
  registerDecorator,
  ValidationOptions,
  ValidationArguments,
} from 'class-validator';

export function IsStrongPassword(
  minLength: number = 8,  // Default to 8 if not provided
  maxLength: number = 20, // Default to 20 if not provided
  validationOptions?: ValidationOptions
) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isStrongPassword',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        /**
         * Validate the password to ensure it meets the strong password criteria.
         * @param value - The password value to validate.
         * @param args - The validation arguments.
         * @returns `true` if the password meets the requirements, otherwise `false`.
         */
        validate(value: any, args: ValidationArguments) {
          if (typeof value !== 'string') return false;

          // Password validation regex with min and max length constraints
          const strongPasswordRegex = new RegExp(
            `^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?#&])[A-Za-z\\d@$!%*?#&]{${minLength},${maxLength}}$`
          );

          return strongPasswordRegex.test(value);
        },

        /**
         * Default error message for password validation failure.
         * @param args - The validation arguments.
         * @returns A custom error message explaining the password criteria.
         */
        defaultMessage(args: ValidationArguments) {
          return `${args.property} must be between ${minLength} and ${maxLength} characters long, include at least one uppercase letter, one lowercase letter, one number, and one special character.`;
        },
      },
    });
  };
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\package.json ===

{
  "name": "@kikerepo/application-common",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "@kikerepo/contracts-common": "workspace:*",
    "@kikerepo/infrastructure-common": "workspace:*",
    "fp-ts": "^2.16.9"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "references": [

  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\src\index.ts ===

export * from './middleware';
export * from './behaviours';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\src\Result.ts ===

import { Either, left, right } from 'fp-ts/Either';

/**
 * Represents the outcome of an operation, which can be either an error or a success.
 */
export type Result<E, T> = Either<E, T>;

/**
 * Helper function to create a failure result.
 * @param error The error value.
 */
export const failure = <E, T = never>(error: E): Result<E, T> => left(error);

/**
 * Helper function to create a success result.
 * @param value The success value.
 */
export const success = <E = never, T = any>(value: T): Result<E, T> => right(value);




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\src\behaviours\AuthorizationBehaviour.ts ===

 /* export const AuthorizationBehaviour = (
  req: Request,
    res: Response,
    next: NextFunction
  ): void => {
    // 1) Leer el header Authorization
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ message: 'No token provided' });
    }

    // 2) Verificar formato: "Bearer <token>"
    const parts = authHeader.split(' ');
    if (parts.length !== 2 || parts[0] !== 'Bearer') {
      return res.status(401).json({ message: 'Invalid token format' });
    }

    const token = parts[1];

    // 3) Comprobar el token (tokenFake en este ejemplo)
    if (token !== 'tokenFake') {
      return res.status(401).json({ message: 'Invalid token' });
    }

    // 4) Si es válido, continuar con la ejecución
    next();
  };
*/



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\src\behaviours\index.ts ===

export { ValidationBehaviour } from './ValidationBehaviour';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\src\behaviours\ValidationBehaviour.ts ===

// src/application/common/services/ValidationService.ts
import { validate } from 'class-validator'; // validate function from class-validator
import { ValidationError } from '@kikerepo/contracts-common'; // Custom error class

export class ValidationBehaviour {
  /**
   * Validate an object based on class-validator decorators.
   * @param target - The object to validate (must be an instance of a class with class-validator decorators).
   * @throws ValidationError - If validation fails, an error is thrown with the formatted errors.
   */
  public async validate<T extends object>(target: T): Promise<void> {
    // Perform the validation using class-validator
    const validationErrors = await validate(target);

    if (validationErrors.length > 0) {
      // Map validation errors into Record<string, string[]>
      const formattedErrors: Record<string, string[]> = {};

      validationErrors.forEach((error) => {
        const property = error.property;
        const messages = error.constraints ? Object.values(error.constraints) : [];
        formattedErrors[property] = messages;
      });

      // Throw a formatted validation error
      throw new ValidationError(formattedErrors);
    }
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\src\middleware\ErrorHandlerMiddleware.ts ===

import { BaseError, InternalError, ValidationError } from '@kikerepo/contracts-common';
import { Request, Response, NextFunction } from 'express';
import { logger } from '@kikerepo/infrastructure-common';
// Función para manejar la respuesta de errores
const handleErrorResponse = (err: BaseError, res: Response): void => {
  const { message, errorCode, statusCode, timestamp, context, stack } = err;

  // Control de entorno para ocultar detalles en producción
  const isProduction = process.env.NODE_ENV === 'production';

  // Si el entorno es producción, ocultamos detalles sensibles como el stack trace
  const errorResponse: any = {
    code: errorCode,
    message,
    statusCode,
    timestamp,
    context,
  };

  // En producción no se debe exponer el stack trace
  if (!isProduction && stack) {
    errorResponse.stack = stack;  // Agregamos el stack solo si no es producción
  }

  res.status(statusCode).json(errorResponse);
};

// Middleware para manejar errores
export const ErrorHandlerMiddleware = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  let context = {};

  // Si el error es de validación, manejamos el caso por separado
  if (err instanceof ValidationError) {
    context = {
      input: req.body,  // Aquí se incluyen los datos de la solicitud, si es relevante
      fieldErrors: err.validationErrors,  // Los errores de validación
    };
    logger.debug(err.name, context);
    return handleErrorResponse(err, res);
  }

  // Para cualquier otro error que sea instancia de BaseError, usamos la misma lógica
  if (err instanceof BaseError) {
    context = {
      requestBody: req.body,
      endpoint: req.url,
    };
    logger.debug(err.name, context);
    return handleErrorResponse(err, res);  // Llamamos a la función de manejo de errores para BaseError
  }

  // Para errores no controlados o cualquier otro tipo de error, lo manejamos como un error genérico
  const internalError = new InternalError();

  // Aquí agregamos el stack trace en el error interno para depuración
  internalError.stack = err.stack;

  // Si hay un error interno, puedes agregar más contexto si es necesario
  context = {
    environment: process.env.NODE_ENV,
    endpoint: req.url,
    requestBody: req.body,
  };
  logger.debug(internalError.name, context);
  return handleErrorResponse(internalError, res);  // Llamamos a la función para manejar el error interno
};




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\src\middleware\index.ts ===

export {ErrorHandlerMiddleware} from './ErrorHandlerMiddleware';
export {ValidationMiddleware} from './ValidationMiddleware';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\application\_common\src\middleware\ValidationMiddleware.ts ===

// packages/infrastructure/_common/src/middleware/ValidationMiddleware.ts
import { plainToInstance } from 'class-transformer';
import { validate } from 'class-validator';
import { Request, Response, NextFunction, RequestHandler } from 'express';
import { ValidationError } from '@kikerepo/contracts-common';

/**
 * Validation middleware for Express using class-transformer + class-validator.
 * 
 * @param dtoClass The DTO class to validate (must have class-validator decorators).
 * @returns A RequestHandler that validates req.body and either returns 400 or calls next().
 */
export function ValidationMiddleware(
  dtoClass: new (...args: any[]) => object
): RequestHandler {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      // 1) Transform the plain JSON body into an instance of dtoClass
      const dtoObject = plainToInstance(dtoClass, req.body);

      // 2) Validate the instance
      const errors = await validate(dtoObject);

      if (errors.length > 0) {
        // 3) If errors, format them
        const formatted: Record<string, string[]> = {};

        for (const err of errors) {
          const property = err.property;
          const constraints = err.constraints ? Object.values(err.constraints) : [];
          formatted[property] = constraints;
        }

        // 4) Respond with 400 and a ValidationError shape
        //    Note: Do NOT return the `Response` object; call `res.json(...)` then `return;`
        res.status(400).json(new ValidationError(formatted));
        return; // ensures TypeScript sees our function returning void
      }

      // 5) No errors: move on to the next middleware / route handler
      next();
    } catch (err) {
      // For unexpected errors, let your global ErrorHandlerMiddleware handle it
      next(err);
    }
  };
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\package.json ===

{
  "name": "@kikerepo/contracts-user",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "@kikerepo/domain-common": "workspace:*"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist", // Compiled files go to dist/
    "rootDir": "./src", // Only source files are included
    "composite": true, // Required for project references
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "references": [
    { "path": "../_common" } // Uses compiled @kikerepo/contracts-common
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\index.ts ===

export * from './responses';
export * from './requests';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\requests\ChangePasswordRequest.ts ===






=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\requests\ForgotPasswordRequest.ts ===






=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\requests\index.ts ===

export * from './LoginRequest';
export * from './RegisterRequest';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\requests\LoginRequest.ts ===


// packages/contracts/user/src/requests/UserLoginRequest.ts
export interface LoginRequest {
    email: string;
    password: string;
  }
  



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\requests\RegisterRequest.ts ===

export class RegisterRequest {
  email: string;
  password: string;
  phone?: string;

  constructor(email: string, password: string, phone?: string) {
    this.email = email;
    this.password = password;
    this.phone = phone;
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\responses\ChangePasswordResponse.ts ===






=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\responses\ForgotPaswordResponse.ts ===






=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\responses\index.ts ===

export * from './LoginResponse';
export * from './RegisterResponse';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\responses\LoginResponse.ts ===

  export interface LoginResponse {
    token: string;
  }



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\user\src\responses\RegisterResponse.ts ===

// src/application/user/commands/UserRegisterResponse.ts
export class RegisterResponse {
  userId: string;
  email: string;

  constructor(userId: string, email: string) {
    this.userId = userId;
    this.email = email;
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\package.json ===

{
  "name": "@kikerepo/contracts-common",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "references": [

  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\src\index.ts ===

export * from './errors';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\src\errors\BaseError.ts ===

export abstract class BaseError extends Error {
  public readonly statusCode: number;
  public readonly timestamp: string;
  public readonly errorCode: string;
  public readonly context?: any;

  constructor(
    message: string,
    statusCode: number,
    errorCode: string,
    context?: any
  ) {
    super(message);
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.timestamp = new Date().toISOString(); // Marca de tiempo en formato ISO
    this.context = context; // Información adicional si es necesario

    // Asegurarse de que el nombre del error esté configurado correctamente
    this.name = this.constructor.name;

    // Este método permite la correcta herencia del stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }

  // Método para serializar el error en formato JSON
  public toJSON() {
    return {
      message: this.message,
      code: this.errorCode,
      statusCode: this.statusCode,
      timestamp: this.timestamp,
      context: this.context,
    };
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\src\errors\ConflictError.ts ===

import { BaseError } from './BaseError';

export class ConflictError extends BaseError {
  constructor(message: string = 'An internal server error occurred', context?: any) {
    super(message, 409, 'CONFLICT', context); // Llamamos al constructor de BaseError
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\src\errors\index.ts ===

export * from './BaseError';
export * from './InternalError';
export * from './ValidationError';
export * from './NotFoundError';
export * from './ConflictError';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\src\errors\InternalError.ts ===

import { BaseError } from './BaseError';

export class InternalError extends BaseError {
  constructor(message: string = 'An internal server error occurred', context?: any) {
    super(message, 500, 'INTERNAL_ERROR', context); // Llamamos al constructor de BaseError
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\src\errors\NotFoundError.ts ===

import { BaseError } from './BaseError';

export class NotFoundError extends BaseError {
  constructor(message: string = 'An internal server error occurred', context?: any) {
    super(message, 404, 'NOT FOUND', context); // Llamamos al constructor de BaseError
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\contracts\_common\src\errors\ValidationError.ts ===

import { BaseError } from './BaseError';

export class ValidationError extends BaseError {
  public readonly validationErrors: Record<string, string[]>;

  constructor(validationErrors: Record<string, string[]>, context?: any) {
    // Usamos el constructor de BaseError, agregamos un mensaje y el código de estado 400 para errores de validación
    super('One or more validation errors occurred.', 400, 'VALIDATION_ERROR', context);
    this.validationErrors = validationErrors;
  }

  /**
   * Converts the ValidationError into a JSON-serializable format.
   */
  toJSON() {
    return {
      message: this.message,
      code: this.errorCode,  // Usamos errorCode en lugar de un valor estático
      statusCode: this.statusCode,
      timestamp: this.timestamp,  // Agregamos el timestamp de la clase base
      validationErrors: this.validationErrors,
      context: this.context,  // Contexto adicional si se pasó
    };
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\package.json ===

{
  "name": "@kikerepo/domain-user",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "@kikerepo/domain-common": "workspace:*"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist", // Compiled files go to dist/
    "rootDir": "./src", // Only source files are included
    "composite": true, // Required for project references
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src", "../../../services/service-authentication/src/bootstrap/tokens.ts"],
  "exclude": ["node_modules", "dist"],
  "references": [
    { "path": "../_common" } // Uses compiled @kikerepo/domain-common
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\index.ts ===

export * from './value-objects';
export * from './events';
export * from './interfaces';
export * from './entities';






=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\entities\index.ts ===

export { User } from './User'



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\entities\User.ts ===

// domain-user/src/entities/User.ts
import { AggregateRoot, CreationDate, DeletionDate } from '@kikerepo/domain-common';
import { UserId, Email, HashedPassword, Phone} from '../value-objects';
import { UserCreatedEvent } from '../events/UserCreatedEvent';

export class User extends AggregateRoot<UserId> {
  private _email: Email;
  private _password: HashedPassword;
  private _phone?: Phone;

  /**
   * El constructor recibe VO ya construidos (y no dispara eventos).
   * Lo hacemos público, pero OJO: 
   * - Normalmente lo dejaríamos `private` o `protected` 
   *   si quieres forzar a que siempre usen la factoría `createUnique`.
   */
  private constructor(
    id: UserId,
    email: Email,
    password: HashedPassword,
    phone?: Phone,
    creationDate?: CreationDate,
    deletionDate?: DeletionDate,
  ) {
    super(id,creationDate,deletionDate);
    this._email = email;
    this._password = password;
    this._phone = phone;
    this.validate();
  }

  /**
   * Método estático/factoría para crear un "User" *nuevo*.
   * Recibe valores primitivos, construye VO, llama al constructor
   * y emite un evento.
   */
  public static createUnique(
    email: Email,
    password: HashedPassword,
    phone?: Phone
  ): User {
    // 1) Generar ID y crear Value Objects
    const userId = new UserId(); // genera un UUIDv6 (por ejemplo)

    // 2) Llamar al constructor con VO
    const user = new User(userId, email, password, phone);

    // 3) Emitir evento de dominio para un user nuevo
    user.addDomainEvent(
      new UserCreatedEvent(userId.value, email.value, phone?.value),
    );

    return user;
  }
  public static map(
    id: string,
    email: string,
    password: string,
    phone: string|null,
    creationDate: Date,
    deletionDate: Date|null
  ): User {
    // 1) Generar ID y crear Value Objects
    const userId = new UserId(id); // genera un UUIDv6 (por ejemplo)
    const emailVO = new Email(email); 
    const passwordVO = new HashedPassword(password);
    const phoneVO = phone ? new Phone(phone) : undefined;
    const creationDateVO = new CreationDate(creationDate) ;
    const deletionDateVO = deletionDate ? new DeletionDate(deletionDate) : undefined;
    // 2) Llamar al constructor con VO
    const user = new User(userId, emailVO, passwordVO, phoneVO,creationDateVO,deletionDateVO);
    return user;
  }
  
  private validate(): void {
    // Aquí podrías poner chequeos complementarios (si fuese necesario)
    if (!this._email) {
      throw new Error('Email requerido');
    }
    if (!this._password) {
      throw new Error('Password requerida');
    }
  }

  // Getters
  get id(): UserId {
    return this._id;
  }

  get email(): Email {
    return this._email;
  }

  get password(): HashedPassword {
    return this._password;
  }

  get phone(): Phone | undefined {
    return this._phone;
  }

  public changePassword(newPassword: HashedPassword) {
    this._password = new HashedPassword(newPassword.value);
    // Emite un PasswordChangedEvent si deseas
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\events\index.ts ===

// shared/src/domain/valueObjects/index.ts
export { UserCreatedEvent } from './UserCreatedEvent';

// Export other value objects as needed




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\events\UserCreatedEvent.ts ===

import { DomainEvent } from '@kikerepo/domain-common';

export class UserCreatedEvent extends DomainEvent {
  constructor(
    public readonly userId: string,
    public readonly email: string,
    public readonly phone?: string // Optional phone
  ) {
    super();
  }

  eventName(): string {
    return 'UserCreatedEvent';
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\interfaces\IHashingService.ts ===

import { InputPassword } from "../value-objects";
import { HashedPassword } from "../value-objects/HashedPassword";
export const IHashingServiceToken = Symbol('IHashingService');

export interface IHashingService {
  hash(password: InputPassword): Promise<HashedPassword>;
  verify(hashedPassword: HashedPassword, password: InputPassword): Promise<boolean>;
}



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\interfaces\index.ts ===


export { IUserRepository, IUserRepositoryToken } from './IUserRepository';
export { IHashingService, IHashingServiceToken } from './IHashingService';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\interfaces\IUserRepository.ts ===

import { User } from '../entities/User';

// 1) Declare a unique Symbol to represent the repository token.
export const IUserRepositoryToken = Symbol('IUserRepository');

// 2) Define the interface itself.
export interface IUserRepository {
  save(user: User): Promise<void>;
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\value-objects\Email.ts ===

import { ValueObject } from '@kikerepo/domain-common';

export class Email extends ValueObject<string> {
  constructor(email: string) {
    super(email);
    if (!this.isValidEmail(email)) {
      throw new Error('Invalid email address');
    }
  }

  private isValidEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
}



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\value-objects\HashedPassword.ts ===

import { ValueObject } from '@kikerepo/domain-common';


export class HashedPassword extends ValueObject<string> {
  // Private constructor to prevent direct instantiation
  public constructor(hashedPassword: string) {
    super(hashedPassword);
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\value-objects\index.ts ===

export { Email } from './Email';
export { HashedPassword } from './HashedPassword';
export { Phone } from './Phone';
export { UserId } from './UserId';
export { InputPassword } from './InputPassword';






=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\value-objects\InputPassword.ts ===

import { ValueObject } from '@kikerepo/domain-common';


export class InputPassword extends ValueObject<string> {
  constructor(password: string) {
    super(password);
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\value-objects\Phone.ts ===

import { ValueObject } from '@kikerepo/domain-common';


export class Phone extends ValueObject<string> {
  constructor(phone: string) {
    super(phone);
    if (!this.isValidPhone(phone)) {
      throw new Error('Invalid phone number.');
    }
  }

  private isValidPhone(phone: string): boolean {
    return /^\+?[1-9]\d{1,14}$/.test(phone); // E.164 international phone number format
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\user\src\value-objects\UserId.ts ===


import { ValueObject } from '@kikerepo/domain-common';
import { generateUUIDv6 } from '@kikerepo/utils-uuid6';

/**
 * Value Object representing the ID of a User Entity.
 */
export class UserId extends ValueObject<string> {
  constructor(id?: string) {
    super(id ? id : generateUUIDv6());
  }

}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\package.json ===

{
  "name": "@kikerepo/domain-common",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "@kikerepo/utils-uuid6": "workspace:*"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "references": [
    { "path": "../../utils/uuid6" } // Explicit dependency on @kikerepo/utils-uuid6
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\AggregateRoot.ts ===

// packages/shared/src/domain/aggregateRoots/AggregateRoot.ts

import { Entity } from './Entity';
import { ValueObject } from './ValueObject';
import { DomainEvent } from './DomainEvent';

export abstract class AggregateRoot<TId extends ValueObject<string>> extends Entity<TId> {
  private readonly _domainEvents: DomainEvent[] = [];

  /**
   * Adds a new domain event to the aggregate.
   * @param event The domain event to add.
   */
  protected addDomainEvent(event: DomainEvent): void {
    this._domainEvents.push(event);
  }

  /**
   * Returns all domain events emitted by this aggregate.
   * @returns A copy of the list of domain events.
   */
  public get domainEvents(): DomainEvent[] {
    return [...this._domainEvents];
  }

  /**
   * Clears all domain events from the aggregate.
   */
  public clearDomainEvents(): void {
    this._domainEvents.length = 0;
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\AggregateRootId.ts ===

// packages/shared/src/domain/valueObjects/AggregateRootId.ts
import { ValueObject } from './ValueObject';
// Replace with your actual UUID v6 generator
import { generateUUIDv6 } from '@kikerepo/utils-uuid6';

export class AggregateRootId extends ValueObject<string> {
  constructor(value?: string) {
    super(value ? value : generateUUIDv6());
  }
  toString(): string {
    throw new Error('Method not implemented.');
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\DomainError.ts ===

export class DomainError extends Error {
  constructor(message: string) {
    super(message);
    this.name += '[DomainError]';
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\DomainEvent.ts ===

export abstract class DomainEvent {
  public readonly occurredAt: Date;
  public readonly eventId: string;

  constructor() {
    this.occurredAt = new Date();
    this.eventId = DomainEvent.generateId();
  }

  private static generateId(): string {
    // Generate a unique identifier for the event (can be UUID or similar)
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }

  abstract eventName(): string; // Each event should define its own name
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\Entity.ts ===

// packages/shared/src/domain/entities/Entity.ts

import { CreationDate, DeletionDate } from './value-objects';
import { ValueObject } from './ValueObject';

export abstract class Entity<TId extends ValueObject<string>> {
  protected readonly _id: TId;
  protected readonly _creationDate: CreationDate;
  private _deletionDate?: DeletionDate;

  constructor(id: TId, creationDate?: CreationDate, deletionDate?: DeletionDate) {
    this._id = id;
    this._creationDate = creationDate?? new CreationDate();
    this._deletionDate = deletionDate?? undefined;
  }

  public get creationDate(): CreationDate {
    return this._creationDate;
  }

  public get id(): TId {
    return this._id;
  }

  public get deletionDate(): DeletionDate | undefined {
    return this._deletionDate;
  }

  public isDeleted(): boolean {
    return !!this._deletionDate;
  }

  
  public delete(deletionDate: DeletionDate): void {
    if (this._deletionDate) {
      throw new Error('Entity is already deleted.');
    }
    this._deletionDate = deletionDate;
  }

  public equals(entity?: Entity<TId>): boolean {
    if (entity === null || entity === undefined) {
      return false;
    }

    if (entity === this) {
      return true;
    }

    if (entity.constructor !== this.constructor) {
      return false;
    }

    return this.id.equals(entity.id);
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\index.ts ===

export * from './ValueObject';
export * from './Entity';
export * from './AggregateRoot';
export * from './DomainEvent';
export * from './DomainError';
export * from './value-objects';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\ValueObject.ts ===

export abstract class ValueObject<T> {
  private readonly _value: T;

  constructor(value: T) {
    if (value === null || value === undefined) {
      throw new Error('ValueObject cannot be null or undefined');
    }
    this._value = Object.freeze(value); // Make the value immutable
  }

  /**
   * Gets the encapsulated value.
   */
  get value(): T {
    return this._value;
  }

  /**
   * Checks equality between two value objects.
   * @param other - The other value object to compare.
   * @returns True if the values are equal, false otherwise.
   */
  public equals(other: ValueObject<T>): boolean {
    if (other === null || other === undefined) {
      return false;
    }

    return JSON.stringify(this._value) === JSON.stringify(other.value);
  }

  /**
   * Converts the value to a string.
   * @returns The string representation of the encapsulated value.
   */
  public toString(): string {
    return String(this._value);
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\interfaces\IEntityId.ts ===

export interface IEntityId {
  /**
   * Returns the string representation of the ID.
   * Useful for serialization and logging.
   */
  toString(): string;

  /**
   * Compares this ID with another for equality.
   * @param id - The ID to compare with.
   * @returns `true` if both IDs are equal, `false` otherwise.
   */
  equals(id: IEntityId): boolean;
}



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\interfaces\IErrorResponse.ts ===

// packages/shared/src/errors/interfaces/IErrorResponse.ts

export interface IErrorResponse {
  status: number;
  message: string;
  errors?: string[];
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\interfaces\index.ts ===

// shared/src/domain/interfaces/index.ts
export * from './IEntityId';
export * from './IErrorResponse';
// Export other interfaces as needed




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\value-objects\CreationDate.ts ===

export class CreationDate {
    private readonly _value: Date;
  
    constructor(date?: Date) {
      this._value = date ? new Date(date) : new Date();
      this.validate();
    }
  
    private validate() {
      if (!(this._value instanceof Date) || isNaN(this._value.getTime())) {
        throw new Error('Invalid creation date.');
      }
  
      const now = new Date();
      if (this._value > now) {
        throw new Error('Creation date cannot be in the future.');
      }
    }
  
    get value(): Date {
      return new Date(this._value);
    }
  
    equals(other: CreationDate): boolean {
      return this._value.getTime() === other._value.getTime();
    }
  
    toString(): string {
      return this._value.toISOString();
    }
  }
  



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\value-objects\DeletionDate.ts ===

export class DeletionDate {
    private readonly _value: Date;
  
    constructor(date?: Date) {
      this._value = date ? new Date(date) : new Date();
      this.validate();
    }
  
    private validate() {
      if (!(this._value instanceof Date) || isNaN(this._value.getTime())) {
        throw new Error('Invalid deletion date.');
      }
  
      const now = new Date();
      if (this._value > now) {
        throw new Error('Creation date cannot be in the future.');
      }
    }
  
    get value(): Date {
      return new Date(this._value);
    }
  
    equals(other: DeletionDate): boolean {
      return this._value.getTime() === other._value.getTime();
    }
  
    toString(): string {
      return this._value.toISOString();
    }
  }
  



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\domain\_common\src\value-objects\index.ts ===

export * from './CreationDate';
export * from './DeletionDate';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\user\package.json ===

{
  "name": "@kikerepo/infrastructure-user",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "@kikerepo/domain-user": "workspace:*",
    "@kikerepo/infrastructure-common": "workspace:*",
    "@prisma/client": "^6.2.1",
    "mongoose": "^6.8.0"
  },
  "devDependencies": {
    "prisma": "^6.2.1"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\user\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist", // Compiled files go to dist/
    "rootDir": "./src", // Only source files are included
    "composite": true, // Required for project references
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "references": [
    { "path": "../_common" } // Uses compiled @kikerepo/domain-common
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\user\src\index.ts ===

export * from './services';
export * from './persistance'



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\user\src\persistance\index.ts ===

export * from './UserDatabase';
export * from './UserRepository';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\user\src\persistance\UserDatabase.ts ===

// services/service-authentication/src/bootstrap/prismaClient.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function connectPrisma(): Promise<void> {
  try {
    await prisma.$connect();
    console.log('[PrismaClient] Connected to PostgreSQL');
  } catch (error) {
    console.error('[PrismaClient] Connection error:', error);
    process.exit(1);
  }
}

export async function disconnectPrisma(): Promise<void> {
  try {
    await prisma.$disconnect();
    console.log('[PrismaClient] Disconnected from PostgreSQL');
  } catch (error) {
    console.error('[PrismaClient] Disconnection error:', error);
  }
}

export { prisma };




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\user\src\persistance\UserRepository.ts ===

import { IUserRepository} from '@kikerepo/domain-user';
import { User } from '@kikerepo/domain-user';
import { prisma } from './UserDatabase';
import { injectable } from 'inversify';
import { logger } from '@kikerepo/infrastructure-common'; // <--- Logger

@injectable()
export class UserRepository implements IUserRepository {
  async save(user: User): Promise<void> {
    logger.debug('[UserRepository] Saving user', { userId: user.id.value });
    await prisma.user.upsert({
      where: { id: user.id.value },
      update: {
        email: user.email.value,
        password: user.password.value,
        phone: user.phone?.value,
      },
      create: {
        id: user.id.value,
        email: user.email.value,
        password: user.password.value,
        phone: user.phone?.value,
      },
    });
  }

  async findById(id: string): Promise<User | null> {
    logger.debug('[UserRepository] Finding user by ID', { id });
    const userRecord = await prisma.user.findUnique({ where: { id } });
    if (!userRecord) {
      logger.debug('[UserRepository] No user found', { id });
      return null;
    }
    return User.map(
      userRecord.id,
      userRecord.email,
      userRecord.password,
      userRecord.phone,
      userRecord.createdAt,
      userRecord.deletedAt
    );
  }

  async findByEmail(email: string): Promise<User | null> {
    logger.debug('[UserRepository] Finding user by email', { email });
    const userRecord = await prisma.user.findUnique({ where: { email } });
    if (!userRecord) {
      logger.debug('[UserRepository] No user found', { email });
      return null;
    }
    return User.map(
      userRecord.id,
      userRecord.email,
      userRecord.password,
      userRecord.phone,
      userRecord.createdAt,
      userRecord.deletedAt
    );
  }
}



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\user\src\services\Argon2HashingService.ts ===

// infrastructure/services/Argon2HashingService.ts
import { IHashingService ,HashedPassword, InputPassword } from '@kikerepo/domain-user';
import argon2 from 'argon2';
import { injectable } from 'inversify';
@injectable()

export class Argon2HashingService implements IHashingService {
  async hash(password: InputPassword): Promise<HashedPassword> {
    var hash = await argon2.hash(password.value, { type: argon2.argon2id });
    return new HashedPassword(hash);
  }

  async verify(hashedPassword: HashedPassword, inputPassword: InputPassword): Promise<boolean> {
    return argon2.verify(hashedPassword.value, inputPassword.value);
  }
}



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\user\src\services\index.ts ===

export {Argon2HashingService} from './Argon2HashingService';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\package.json ===

{
  "name": "@kikerepo/infrastructure-common",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "@kikerepo/contracts-common": "workspace:*",
    "jsonwebtoken": "^9.0.2",
    "winston": "^3.17.0"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src", "types"]  ,
  "exclude": ["node_modules", "dist"],
  "references": [
    { "path": "../../contracts/_common" } // Uses compiled @kikerepo/contracts-common
  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\src\index.ts ===

export * from './middleware';
export * from './authentication';
export * from './logging';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\src\authentication\authenticationToken.ts ===

import jwt, { JwtPayload } from 'jsonwebtoken';

const SECRET_KEY = process.env.JWT_SECRET || 'default-secret-key'; // Replace with env variable

export const generateToken = (payload: object): string => {
  return jwt.sign(payload, SECRET_KEY, { expiresIn: '1h' });
};

export const verifyToken = (token: string): JwtPayload => {
  try {
    const decoded = jwt.verify(token, SECRET_KEY);

    if (typeof decoded === 'string') {
      throw new Error('Invalid token payload: Expected an object');
    }

    return decoded; // Now TypeScript knows it's a JwtPayload
  } catch (err) {
    throw new Error('Invalid or expired token');
  }
};




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\src\authentication\index.ts ===

export { generateToken, verifyToken } from './authenticationToken';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\src\logging\index.ts ===

export {logger} from './logger';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\src\logging\logger.ts ===

// packages/infrastructure/_common/src/logging/logger.ts
import { createLogger, format, transports } from 'winston';
import chalk from 'chalk';
import dayjs from 'dayjs';

const { combine, timestamp, printf } = format;

// Formato personalizado
const consoleFormat = printf((info) => {
  // Aseguramos que el timestamp es una cadena
  const rawTimestamp = typeof info.timestamp === 'string' ? info.timestamp : new Date().toISOString();
  
  // Formateamos la fecha usando dayjs
  const formattedDate = dayjs(rawTimestamp).format('YYYY-MM-DD HH:mm:ss');
  const greyDate = chalk.gray(formattedDate);

  // Asignamos colores al nivel
  let coloredLevel: string;
  switch (info.level) {
    case 'error':
      coloredLevel = chalk.red(info.level);
      break;
    case 'warn':
      coloredLevel = chalk.yellow(info.level);
      break;
    case 'info':
      coloredLevel = chalk.green(info.level);
      break;
    case 'debug':
      coloredLevel = chalk.blue(info.level);
      break;
    default:
      coloredLevel = info.level; // Sin color para niveles personalizados
  }

  // Extraemos los datos adicionales
  const { level, message, timestamp, ...rest } = info;
  const extraData = Object.keys(rest).length ? JSON.stringify(rest) : '';

  return `${greyDate} [${coloredLevel}]: ${message} ${extraData}`;
});

export const logger = createLogger({
  level: 'debug',
  format: combine(
    timestamp(),
    consoleFormat
  ),
  transports: [
    new transports.Console(),
  ],
});
/*
// packages/infrastructure/_common/src/logging/logger.ts
import { createLogger, format, transports } from 'winston';
import chalk from 'chalk';
import dayjs from 'dayjs';

const { combine, timestamp, printf } = format;

// Formato personalizado
const consoleFormat = printf((info) => {
  // Aseguramos que el timestamp es una cadena
  const rawTimestamp = typeof info.timestamp === 'string' ? info.timestamp : new Date().toISOString();
  
  // Formateamos la fecha usando dayjs
  const formattedDate = dayjs(rawTimestamp).format('YYYY-MM-DD HH:mm:ss');
  const greyDate = chalk.gray(formattedDate);

  // Asignamos colores al nivel
  let coloredLevel: string;
  switch (info.level) {
    case 'error':
      coloredLevel = chalk.red(info.level);
      break;
    case 'warn':
      coloredLevel = chalk.yellow(info.level);
      break;
    case 'info':
      coloredLevel = chalk.green(info.level);
      break;
    case 'debug':
      coloredLevel = chalk.blue(info.level);
      break;
    default:
      coloredLevel = info.level; // Sin color para niveles personalizados
  }

  // Extraemos los datos adicionales
  const { level, message, timestamp, ...rest } = info;
  const extraData = Object.keys(rest).length ? JSON.stringify(rest) : '';

  return `${greyDate} [${coloredLevel}]: ${message} ${extraData}`;
});

export const logger = createLogger({
  level: 'debug',
  format: combine(
    timestamp(),
    consoleFormat
  ),
  transports: [
    new transports.Console(),
  ],
});
*/



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\src\middleware\AuthenticationMiddleware.ts ===

import { Request, Response, NextFunction } from 'express';

/**
 * Middleware de autenticación que comprueba "Authorization: Bearer <token>".
 * Retorna un "Response" si hay error, o "void" si llama a next() sin devolver nada.
 */
export function AuthenticationMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void | Response {
  // 1) Leer el header Authorization
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ message: 'No token provided' });
  }

  // 2) Verificar formato: "Bearer <token>"
  const parts = authHeader.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') {
    return res.status(401).json({ message: 'Invalid token format' });
  }

  const token = parts[1];

  // 3) Comprobar el token (tokenFake en este ejemplo)
  if (token !== 'tokenFake') {
    return res.status(401).json({ message: 'Invalid token' });
  }

  // 4) Si es válido, continuar con la ejecución
  next();
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\src\middleware\index.ts ===

export { RequestLoggerMiddleware } from './RequestLoggerMiddleware';
export { AuthenticationMiddleware } from './AuthenticationMiddleware';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\infrastructure\_common\src\middleware\RequestLoggerMiddleware.ts ===

import { Request, Response, NextFunction } from 'express';
import { logger } from '../logging/logger';

export const RequestLoggerMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  logger.info(`[${req.method}] ${req.url}`, { ip: req.ip });
  next();
};




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\env\index.ts ===

export * from './src/requireEnv';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\env\package.json ===

{
  "name": "@kikerepo/utils-env",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "uuid": "^11.0.5"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\env\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\env\src\index.ts ===

// shared/src/domain/index.ts
export * from './requireEnv';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\env\src\requireEnv.ts ===

export function requireEnv(varName: string): string {
  const value = process.env[varName];
  if (!value) {
    throw new Error(`Missing environment variable: ${varName}`);
  }
  return value;
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\env\__tests__\basic.spec.ts ===

import { generateUUIDv6, isValidUUIDv6 } from "../src/uuid6";

describe('isValidUUIDv6', () => {
  it('should return true for a valid UUID v6', () => {
    const validUUIDv6 = '1e79e27e-8a88-6eb6-9405-0242ac120002';
    expect(isValidUUIDv6(validUUIDv6)).toBe(true);
  });

  it('should return false for a UUID v4', () => {
    const validUUIDv4 = '550e8400-e29b-41d4-a716-446655440000'; // v4 UUID
    expect(isValidUUIDv6(validUUIDv4)).toBe(false);
  });

  it('should return false for an invalid UUID format', () => {
    const invalidUUID = 'invalid-uuid-string';
    expect(isValidUUIDv6(invalidUUID)).toBe(false);
  });

  it('should return false for an empty string', () => {
    expect(isValidUUIDv6('')).toBe(false);
  });

  it('should return false for null or undefined', () => {
    expect(isValidUUIDv6(null as unknown as string)).toBe(false);
    expect(isValidUUIDv6(undefined as unknown as string)).toBe(false);
  });

  it('should return false for a UUID with the wrong version', () => {
    const wrongVersionUUID = '1e79e27e-8a88-4eb6-9405-0242ac120002'; // Version 4
    expect(isValidUUIDv6(wrongVersionUUID)).toBe(false);
  });

  it('should return false for a UUID with the wrong variant', () => {
    const wrongVariantUUID = '1e79e27e-8a88-6eb6-3405-0242ac120002'; // Variant 001xxxxx
    expect(isValidUUIDv6(wrongVariantUUID)).toBe(false);
  });

  it('should handle case-insensitivity for valid UUID v6', () => {
    const upperCaseUUIDv6 = '1E79E27E-8A88-6EB6-9405-0242AC120002';
    expect(isValidUUIDv6(upperCaseUUIDv6)).toBe(true);
  });
});

describe('generateUUIDv6', () => {
  it('should generate a valid UUID v6', () => {
    const uuid = generateUUIDv6();
    expect(isValidUUIDv6(uuid)).toBe(true);
  });

  it('should generate unique UUIDs for multiple calls', () => {
    const uuidSet = new Set();
    for (let i = 0; i < 1000; i++) {
      const uuid = generateUUIDv6();
      expect(isValidUUIDv6(uuid)).toBe(true); // Ensure validity
      expect(uuidSet.has(uuid)).toBe(false); // Ensure uniqueness
      uuidSet.add(uuid);
    }
  });

  it('should contain the correct version (6)', () => {
    const uuid = generateUUIDv6();
    const version = uuid.split('-')[2][0];
    expect(version).toBe('6');
  });

  it('should contain the correct variant (10xxxxxx)', () => {
    const uuid = generateUUIDv6();
    const variant = parseInt(uuid.split('-')[3][0], 16);
    expect(variant & 0b1100).toBe(0b1000);
  });

  it('should generate UUIDs with increasing timestamps for ordering', () => {
    const uuid1 = generateUUIDv6();
    const uuid2 = generateUUIDv6();
  
    // Extract the timestamp (first 3 components of the UUID: time_low, time_mid, and time_high_and_version)
    const timestamp1 = uuid1.split('-').slice(0, 3).join('');
    const timestamp2 = uuid2.split('-').slice(0, 3).join('');
  
    expect(timestamp1 < timestamp2).toBe(true); // Ensure timestamps are increasing
  });
  
  it('should generate 16-byte UUIDs', () => {
    const uuid = generateUUIDv6();
    const byteLength = Buffer.from(uuid.replace(/-/g, ''), 'hex').length;
    expect(byteLength).toBe(16);
  });

  it('should generate 36-character UUID strings', () => {
    const uuid = generateUUIDv6();
    expect(uuid.length).toBe(36);
  });

  it('should not generate duplicate UUIDs in a high-concurrency environment', () => {
    const uuids = new Set<string>();
    const NUM_UUIDS = 10000;

    for (let i = 0; i < NUM_UUIDS; i++) {
      const uuid = generateUUIDv6();
      expect(isValidUUIDv6(uuid)).toBe(true); // Ensure validity
      expect(uuids.has(uuid)).toBe(false); // Ensure uniqueness
      uuids.add(uuid);
    }
  });
});




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\kafka-client\jest.config.ts ===

import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/?(*.)+(spec|test).[tj]s?(x)'], // Match .spec.ts or .test.ts files
  moduleFileExtensions: ['ts', 'js'],
  modulePathIgnorePatterns: ['<rootDir>/dist/', '.*/dist/'], // Ignore all dist folders
  transform: {
    '^.+\\.ts$': 'ts-jest', // Use ts-jest to transform TypeScript files
  },
};

export default config;




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\kafka-client\package.json ===

{
  "name": "@kikerepo/utils-kafka-client",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "kafkajs": "^2.2.4"
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "jest": "^29.7.0",
    "typescript": "^5.7.3"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\kafka-client\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\kafka-client\src\index.ts ===

// packages/utils/kafka-client/src/index.ts
export * from './KafkaClient';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\kafka-client\src\KafkaClient.ts ===

// packages/utils/kafka-client/src/KafkaClient.ts
import { Kafka, Producer, Consumer, logLevel } from 'kafkajs';

export interface KafkaClientConfig {
  brokers: string[];
  clientId: string;
  consumerGroupId?: string;
}

export class KafkaClient {
  private kafka: Kafka;
  public producer: Producer;
  public consumer: Consumer;

  constructor(config: KafkaClientConfig) {
    this.kafka = new Kafka({
      clientId: config.clientId,
      brokers: config.brokers,
      logLevel: logLevel.INFO
    });

    this.producer = this.kafka.producer();
    this.consumer = this.kafka.consumer({
      groupId: config.consumerGroupId || `${config.clientId}-group`
    });
  }

  async connect(): Promise<void> {
    await Promise.all([
      this.producer.connect(),
      this.consumer.connect()
    ]);
  }

  async disconnect(): Promise<void> {
    await Promise.all([
      this.producer.disconnect(),
      this.consumer.disconnect()
    ]);
  }

  /**
   * Publishes messages to the given topic.
   * @param topic The topic to send messages to.
   * @param messages An array of messages.
   */
  async publish(topic: string, messages: { key?: string; value: string }[]): Promise<void> {
    await this.producer.send({
      topic,
      messages
    });
  }

  /**
   * Subscribes to a topic and runs the provided message handler.
   * @param topic The topic to subscribe to.
   * @param handler An async function that will process each message.
   */
  async subscribe(topic: string, handler: (message: { topic: string; partition: number; key: string | null; value: string | null }) => Promise<void>): Promise<void> {
    await this.consumer.subscribe({ topic, fromBeginning: true });
    await this.consumer.run({
      eachMessage: async ({ topic, partition, message }) => {
        await handler({
          topic,
          partition,
          key: message.key?.toString() || null,
          value: message.value?.toString() || null
        });
      }
    });
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\kafka-client\__tests__\kafkaclient.spec.ts ===




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\redis-client\jest.config.ts ===

import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/?(*.)+(spec|test).[tj]s?(x)'], // Match .spec.ts or .test.ts files
  moduleFileExtensions: ['ts', 'js'],
  modulePathIgnorePatterns: ['<rootDir>/dist/', '.*/dist/'], // Ignore all dist folders
  transform: {
    '^.+\\.ts$': 'ts-jest', // Use ts-jest to transform TypeScript files
  },
};

export default config;




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\redis-client\package.json ===

{
  "name": "@kikerepo/utils-redis-client",
  "version": "1.0.0",
  "description": "Enhanced Redis client with retry, fallback, and circuit breaker capabilities",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "test": "jest --passWithNoTests",
    "lint": "eslint 'src/**/*.ts'",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "opossum": "^8.4.0",
    "redis": "^4.6.7"
  },
  "devDependencies": {
    "@types/opossum": "^8",
    "jest": "^29.7.0"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\redis-client\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\redis-client\src\index.ts ===

export { RedisClient } from './RedisClient';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\redis-client\src\RedisClient.ts ===

import { createClient, RedisClientType } from '@redis/client';

export interface RedisClientConfig {
  host?: string;
  port?: number;
  password?: string;
  url?: string; // Optional for full Redis connection URL
}

export class RedisClient {
  private client: RedisClientType;

  constructor(private config: RedisClientConfig = {}) {
    const { host = '127.0.0.1', port = 6379, password= "mama-redis-1234", url } = config;

    if (url) {
      this.client = createClient({ url });
    } else {
      this.client = createClient({
        socket: { host, port },
        password,
      });
    }
  }

  public async connect(): Promise<void> {
    try {
      await this.client.connect();
      console.info('[RedisClient] Connected to Redis.');
    } catch (error) {
      console.error('[RedisClient] Failed to connect to Redis:', error);
    }
  }

  public async disconnect(): Promise<void> {
    await this.client.disconnect();
    console.info('[RedisClient] Disconnected from Redis.');
  }

  public async set(key: string, value: string): Promise<void> {
    await this.client.set(key, value);
  }

  public async get(key: string): Promise<string | null> {
    return this.client.get(key);
  }
  public async healthCheck(): Promise<{ status: string; message?: string }> {
    try {
      const response = await this.client.ping();
      if (response === 'PONG') {
        return { status: 'UP' };
      } else {
        return { status: 'DOWN', message: 'Unexpected response from Redis.' };
      }
    } catch (error) {
      let message = 'An unknown error occurred';
      if (error instanceof Error) {
        message = error.message; // Narrow the type to Error
      }
      return { status: 'DOWN', message };
    }
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\redis-client\__tests__\redisclient.spec.ts ===

import {RedisClient} from '../src/RedisClient';

describe('RedisClient', () => {
  let redisClient: RedisClient;

  beforeAll(async () => {
    redisClient = new RedisClient({
      host: '127.0.0.1',
      port: 6379,
      password: 'mama-redis-1234', // Add password if required
    });
    await redisClient.connect();
  });

  afterAll(async () => {
    await redisClient.disconnect();
  });

  it('should connect to Redis successfully', async () => {
    const health = await redisClient.healthCheck();
    expect(health.status).toBe('UP');
  });

  it('should set and get values', async () => {
    await redisClient.set('testKey', 'testValue');
    const value = await redisClient.get('testKey');
    expect(value).toBe('testValue');
  });
});




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\uuid6\index.ts ===

export * from './src/uuid6';




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\uuid6\package.json ===

{
  "name": "@kikerepo/utils-uuid6",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc -b",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "test": "jest"
  },
  "dependencies": {
    "uuid": "^11.0.5"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\uuid6\tsconfig.json ===

{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\uuid6\src\index.ts ===

// shared/src/domain/index.ts
export * from './uuid6';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\uuid6\src\uuid6.ts ===

import { randomBytes } from 'crypto';

let lastTimestamp = BigInt(0);

/**
 * Generates a UUID v6 string.
 * UUID v6 embeds timestamps for lexicographical order.
 * @returns {string} The generated UUID v6 string.
 */
export function generateUUIDv6(): string {
  const uuidEpochToUnixEpoch = 12219292800000n; // Offset between UUID epoch (1582) and Unix epoch (1970)
  let now = BigInt(Date.now());

  // Ensure timestamps are strictly increasing
  if (now <= lastTimestamp) {
    now = lastTimestamp + 1n; // Increment the timestamp if it's the same or lower
  }
  lastTimestamp = now;

  // Convert to 100-nanosecond intervals and offset to UUID epoch
  const timestamp = (now + uuidEpochToUnixEpoch) * 10000n;

  // Split the timestamp into 3 parts
  const timeLow = Number(timestamp & 0xFFFFFFFFn); // Lower 32 bits
  const timeMid = Number((timestamp >> 32n) & 0xFFFFn); // Next 16 bits
  const timeHigh = Number((timestamp >> 48n) & 0x0FFFn); // Next 12 bits
  const timeHighAndVersion = timeHigh | 0x6000; // Set version to 6 (0b0110)

  // Generate random clock sequence and node
  const clockSeq = Math.floor(Math.random() * 0x3FFF); // Random 14-bit clock sequence
  const clockSeqHigh = (clockSeq >> 8) | 0x80; // Set variant to 10xxxxxx
  const clockSeqLow = clockSeq & 0xFF;
  const node = randomBytes(6); // Random 48-bit node

  // Construct the UUID byte array
  const uuidBytes = Buffer.alloc(16);
  uuidBytes.writeUInt32BE(timeLow, 0); // 4 bytes
  uuidBytes.writeUInt16BE(timeMid, 4); // 2 bytes
  uuidBytes.writeUInt16BE(timeHighAndVersion, 6); // 2 bytes
  uuidBytes.writeUInt8(clockSeqHigh, 8); // 1 byte
  uuidBytes.writeUInt8(clockSeqLow, 9); // 1 byte
  node.copy(uuidBytes, 10); // 6 bytes

  // Convert to string and format as 8-4-4-4-12
  const hex = uuidBytes.toString('hex');
  return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20, 32)}`;
}

/**
 * Validates if a given string is a valid UUID v6.
 *
 * @param uuid - The UUID string to validate.
 * @returns {boolean} True if the string is a valid UUID v6, false otherwise.
 */
export function isValidUUIDv6(uuid: string): boolean {
  if (!uuid) return false;

  // Regex explicitly checks for version 6 UUIDs
  const uuidV6Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-6[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidV6Regex.test(uuid);
}



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\packages\utils\uuid6\__tests__\basic.spec.ts ===

import { generateUUIDv6, isValidUUIDv6 } from "../src/uuid6";

describe('isValidUUIDv6', () => {
  it('should return true for a valid UUID v6', () => {
    const validUUIDv6 = '1e79e27e-8a88-6eb6-9405-0242ac120002';
    expect(isValidUUIDv6(validUUIDv6)).toBe(true);
  });

  it('should return false for a UUID v4', () => {
    const validUUIDv4 = '550e8400-e29b-41d4-a716-446655440000'; // v4 UUID
    expect(isValidUUIDv6(validUUIDv4)).toBe(false);
  });

  it('should return false for an invalid UUID format', () => {
    const invalidUUID = 'invalid-uuid-string';
    expect(isValidUUIDv6(invalidUUID)).toBe(false);
  });

  it('should return false for an empty string', () => {
    expect(isValidUUIDv6('')).toBe(false);
  });

  it('should return false for null or undefined', () => {
    expect(isValidUUIDv6(null as unknown as string)).toBe(false);
    expect(isValidUUIDv6(undefined as unknown as string)).toBe(false);
  });

  it('should return false for a UUID with the wrong version', () => {
    const wrongVersionUUID = '1e79e27e-8a88-4eb6-9405-0242ac120002'; // Version 4
    expect(isValidUUIDv6(wrongVersionUUID)).toBe(false);
  });

  it('should return false for a UUID with the wrong variant', () => {
    const wrongVariantUUID = '1e79e27e-8a88-6eb6-3405-0242ac120002'; // Variant 001xxxxx
    expect(isValidUUIDv6(wrongVariantUUID)).toBe(false);
  });

  it('should handle case-insensitivity for valid UUID v6', () => {
    const upperCaseUUIDv6 = '1E79E27E-8A88-6EB6-9405-0242AC120002';
    expect(isValidUUIDv6(upperCaseUUIDv6)).toBe(true);
  });
});

describe('generateUUIDv6', () => {
  it('should generate a valid UUID v6', () => {
    const uuid = generateUUIDv6();
    expect(isValidUUIDv6(uuid)).toBe(true);
  });

  it('should generate unique UUIDs for multiple calls', () => {
    const uuidSet = new Set();
    for (let i = 0; i < 1000; i++) {
      const uuid = generateUUIDv6();
      expect(isValidUUIDv6(uuid)).toBe(true); // Ensure validity
      expect(uuidSet.has(uuid)).toBe(false); // Ensure uniqueness
      uuidSet.add(uuid);
    }
  });

  it('should contain the correct version (6)', () => {
    const uuid = generateUUIDv6();
    const version = uuid.split('-')[2][0];
    expect(version).toBe('6');
  });

  it('should contain the correct variant (10xxxxxx)', () => {
    const uuid = generateUUIDv6();
    const variant = parseInt(uuid.split('-')[3][0], 16);
    expect(variant & 0b1100).toBe(0b1000);
  });

  it('should generate UUIDs with increasing timestamps for ordering', () => {
    const uuid1 = generateUUIDv6();
    const uuid2 = generateUUIDv6();
  
    // Extract the timestamp (first 3 components of the UUID: time_low, time_mid, and time_high_and_version)
    const timestamp1 = uuid1.split('-').slice(0, 3).join('');
    const timestamp2 = uuid2.split('-').slice(0, 3).join('');
  
    expect(timestamp1 < timestamp2).toBe(true); // Ensure timestamps are increasing
  });
  
  it('should generate 16-byte UUIDs', () => {
    const uuid = generateUUIDv6();
    const byteLength = Buffer.from(uuid.replace(/-/g, ''), 'hex').length;
    expect(byteLength).toBe(16);
  });

  it('should generate 36-character UUID strings', () => {
    const uuid = generateUUIDv6();
    expect(uuid.length).toBe(36);
  });

  it('should not generate duplicate UUIDs in a high-concurrency environment', () => {
    const uuids = new Set<string>();
    const NUM_UUIDS = 10000;

    for (let i = 0; i < NUM_UUIDS; i++) {
      const uuid = generateUUIDv6();
      expect(isValidUUIDv6(uuid)).toBe(true); // Ensure validity
      expect(uuids.has(uuid)).toBe(false); // Ensure uniqueness
      uuids.add(uuid);
    }
  });
});




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\.env ===

#express settings
APP_HOST=*****
APP_PORT=*****
#redis settings
REDIS_HOST=*****
REDIS_PORT=*****
REDIS_PASSWORD=*****
#database settings
#use ipv4 if possible
#DATABASE_URL="postgresql://postgres:K9z1OIGr6FERGO9i@db.xxwztdkwreeeqibqxbym.supabase.co:5432/postgres" 
#alternative connection string for ipv6
DATABASE_URL=*****
#jwt settings
JWT_SECRET=*****




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\.env.development ===

#express settings
APP_HOST=*****
APP_PORT=*****
#redis settings
REDIS_HOST=*****
REDIS_PORT=*****
REDIS_PASSWORD=*****
#database settings
#use ipv4 if possible
#DATABASE_URL="postgresql://postgres:K9z1OIGr6FERGO9i@db.xxwztdkwreeeqibqxbym.supabase.co:5432/postgres" 
#alternative connection string for ipv6
DATABASE_URL=*****
#jwt settings
JWT_SECRET=*****




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\Dockerfile.development ===

# Usa una imagen base de Node (versión LTS recomendada)
FROM node:18-alpine

# Directorio de trabajo en el contenedor
WORKDIR /app

# --- CAPA DE DEPENDENCIAS ---
# Copia archivos de configuración del monorepo necesarios para instalar dependencias
# Estos archivos se encuentran en la raíz del monorepo
COPY package.json yarn.lock turbo.json .yarnrc.yml ./
# Si usas Yarn v4 con la carpeta .yarn, cópiala también:
COPY .yarn .yarn

# Instala todas las dependencias (usando workspaces)
RUN yarn install

# --- CAPA DE CÓDIGO ---
# Copia todo el código del monorepo al contenedor
COPY . .

# Establece el directorio de trabajo al servicio de autenticación
WORKDIR /app/services/service-authentication

# Expone el puerto en el que el servicio escucha (ajústalo según corresponda)
EXPOSE 5001

# Define la variable de entorno para desarrollo
ENV NODE_ENV=development

# Ejecuta el comando de desarrollo definido en el package.json del servicio.
# Por ejemplo, se asume que en services/service-authentication/package.json existe:
# "scripts": { "dev": "ts-node-dev --respawn --transpileOnly src/index.ts" }
CMD ["yarn", "dev"]




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\jest.config.ts ===

// services/service-authentication/jest.config.mjs

export default {
  preset: 'ts-jest/presets/default-esm', // Use the ESM preset
  testEnvironment: 'node',
  testMatch: ['**/?(*.)+(spec|test).[tj]s?(x)'],
  moduleFileExtensions: ['ts', 'js'],
  modulePathIgnorePatterns: ['<rootDir>/dist/', '.*/dist/'],
  transform: {
    '^.+\\.ts$': ['ts-jest', { useESM: true }], // Enable ESM in ts-jest
  },
  globals: {
    'ts-jest': {
      tsconfig: 'tsconfig.json',
      useESM: true, // Ensure ts-jest uses ESM
    },
  },
  extensionsToTreatAsEsm: ['.ts'], // Treat TypeScript files as ESM
};




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\package.json ===

{
  "name": "@kikerepo/service-authentication",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "prisma:generate": "prisma generate",
    "dev": "yarn prisma:generate && ts-node-dev --respawn -- src/index.ts --transpileOnly",
    "build": "tsc -p tsconfig.json",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "lint": "eslint 'src/**/*.ts'"
  },
  "devDependencies": {
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.7",
    "eslint": "^8.0.0",
    "prisma": "^6.2.1",
    "ts-node-dev": "^2.0.0",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3"
  },
  "dependencies": {
    "@kikerepo/application-user": "workspace:*",
    "@kikerepo/contracts-user": "workspace:*",
    "@kikerepo/domain-user": "workspace:*",
    "@kikerepo/infrastructure-common": "workspace:*",
    "@kikerepo/infrastructure-user": "workspace:*",
    "@kikerepo/utils-env": "workspace:*",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "tsyringe": "^4.8.0"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\tsconfig.json ===

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "rootDir": "src",
    "outDir": "dist",
    "baseUrl": ".",
  },
  "include": ["src", "../../packages/infrastructure/user/src/persistance/databaseConnection.ts"],
  "exclude": ["node_modules", "dist"],
  "references": [

  ]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\src\index.ts ===

// services/service-authentication/src/index.ts
import 'reflect-metadata';
import dotenv from 'dotenv';
import express from 'express';
import { buildContainer, container } from './bootstrap/container';
import { userRoutes } from './routes/UserRoutes';

dotenv.config();

async function startServer() {
  // 1) Build container -> connect Prisma
  await buildContainer();

  // 2) Create Express server
  const app = express();
  app.use(express.json());

  // 3) Mount routes
  app.use('/users', userRoutes);

  // 4) Listen
  const port = process.env.APP_PORT || 3000;
  app.listen(port, () => console.log(`[Auth] Listening on port ${port}`));
}

startServer().catch((err) => {
  console.error('[Auth] Startup error:', err);
  process.exit(1);
});




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\src\bootstrap\container.ts ===

// services/service-authentication/src/bootstrap/container.ts
import { Container } from 'inversify';
import {
  IUserRepositoryToken,
  IHashingServiceToken,
  IUserRepository,
  IHashingService,
} from '@kikerepo/domain-user';
import {
  UserRepository,
  Argon2HashingService,
  // 1) Import connectPrisma
  connectPrisma,
} from '@kikerepo/infrastructure-user';
import {
  RegisterCommandHandler,
  RegisterCommandHandlerToken,
} from '@kikerepo/application-user';
import { UserController, UserControllerToken } from '../controllers/UserController';

const container = new Container();

// -- Bind interfaces to implementations
container.bind<IUserRepository>(IUserRepositoryToken).to(UserRepository);
container.bind<IHashingService>(IHashingServiceToken).to(Argon2HashingService);

// -- Bind your CommandHandler
container.bind<RegisterCommandHandler>(RegisterCommandHandlerToken).to(RegisterCommandHandler);

// -- Bind your Controller
container.bind<UserController>(UserControllerToken).to(UserController);

/**
 * Async function for container initialization + Prisma connection.
 */
export async function buildContainer(): Promise<void> {
  // 2) Connect Prisma before returning
  await connectPrisma();
}

// Export the container as well:
export { container };




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\src\bootstrap\index.ts ===

export * from './container';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\src\controllers\index.ts ===

export * from './UserController';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\src\controllers\UserController.ts ===

// services/service-authentication/src/controllers/UserController.ts

import { Request, Response, NextFunction } from 'express';
import {
  RegisterCommandHandler,
  RegisterCommandHandlerToken,
  RegisterResultToRegisterResponseMapper,
  RegisterRequestToRegisterCommandMapper,
  RegisterCommand,
  RegisterResult
} from '@kikerepo/application-user';
import {
  RegisterRequest,
  RegisterResponse
} from '@kikerepo/contracts-user';
import { injectable, inject } from 'inversify';
import { logger } from '@kikerepo/infrastructure-common'; // <--- Logger

export const UserControllerToken = Symbol('UserControllerToken');
@injectable()
export class UserController {
  constructor(
    @inject(RegisterCommandHandlerToken) private readonly registerCommandHandler: RegisterCommandHandler
  ) {}

  public register = async (
    req: Request<{}, {}, RegisterRequest>,
    res: Response<RegisterResponse>,
    next: NextFunction
  ): Promise<void> => {
    logger.info('Register endpoint called');

    try {
      const command = RegisterRequestToRegisterCommandMapper.toCommand(req.body);
      const result = await this.registerCommandHandler.handle(command);

      if (result instanceof Error) {
        return next(result);
      }

      const response = RegisterResultToRegisterResponseMapper.toResponse(result);
      logger.info('User registered. Sending response');
      res.status(201).json(response);

    } catch (error) {
      next(error);
    }
  };
}



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\src\routes\index.ts ===

export { userRoutes } from './UserRoutes';



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\src\routes\UserRoutes.ts ===

// services/service-authentication/src/routes/UserRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import { container } from '../bootstrap/container';
import { UserController, UserControllerToken } from '../controllers/UserController'; 
import { ErrorHandlerMiddleware, ValidationMiddleware } from '@kikerepo/application-common';
import { RegisterCommand } from '@kikerepo/application-user';
import { NotFoundError } from '@kikerepo/contracts-common';

const userRoutes = Router();

// Resolve the UserController from the container using the defined token
const userController = container.get<UserController>(UserControllerToken);

// Define the POST /register route with validation and controller handler
userRoutes.post(
  '/register',
  ValidationMiddleware(RegisterCommand),
  userController.register.bind(userController) // Ensure correct 'this' context
);

// Optional: Define other user-related routes here
// Example:
// userRoutes.post(
//   '/login',
//   ValidationMiddleware(LoginCommand),
//   userController.login.bind(userController)
// );

// 404 Handler for Undefined Routes within this Router
userRoutes.use((req: Request, res: Response, next: NextFunction) => {
  res.status(404).json( new NotFoundError( ));
});

// Error Handling Middleware
userRoutes.use(ErrorHandlerMiddleware);

export { userRoutes };




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-authentication\__tests__\basic.spec.ts ===

describe('Mailing Service test', () => {
  it('should do a sample test in service-mailing', () => {
    expect("hello").toBe("hello");
  });
});




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-kafka\.env.development ===

# Kafka settings for development
# The advertised listeners are set so that other containers (on the same network) can resolve the Kafka broker
KAFKA_BROKER_ID=*****
KAFKA_ZOOKEEPER_CONNECT=*****
KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=*****
KAFKA_ADVERTISED_LISTENERS=*****
KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=*****




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-kafka\docker-compose.yml ===

version: '3.8'
services:
  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      KAFKA_BROKER_ID: ${KAFKA_BROKER_ID:-1}
      KAFKA_ZOOKEEPER_CONNECT: ${KAFKA_ZOOKEEPER_CONNECT:-zookeeper:2181}
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: ${KAFKA_LISTENER_SECURITY_PROTOCOL_MAP:-PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT}
      KAFKA_ADVERTISED_LISTENERS: ${KAFKA_ADVERTISED_LISTENERS:-PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092}
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: ${KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR:-1}
    ports:
      - "9092:9092"
      - "29092:29092"
    networks:
      - kafka-net

networks:
  kafka-net:
    external: true




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-kafka\Dockerfile.development ===

# Use Node LTS image
FROM node:18-alpine

# Set the working directory
WORKDIR /app

# Copy root-level files (so Yarn workspaces work correctly)
COPY package.json yarn.lock turbo.json .yarnrc.yml ./

# (Optional) If you have a .yarn folder, copy it too
COPY .yarn .yarn

# Install dependencies from the root (Yarn will hoist workspaces if needed)
RUN yarn install --immutable

# Copy all files
COPY . .

# Change directory to the service folder
WORKDIR /app/services/service-kafka

# Expose the port
EXPOSE 3100

# Set environment (development)
ENV NODE_ENV=development

# Start the service
CMD ["yarn", "dev"]




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-kafka\package.json ===

{
  "name": "service-kafka",
  "version": "1.0.0",
  "description": "Kafka server for the monorepo",
  "scripts": {
    "dev": "docker-compose up -d",
    "start": "docker-compose up -d",
    "stop": "docker-compose down",
    "logs": "docker-compose logs -f"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-mailing\.env.development ===

APP_HOST=*****
APP_PORT=*****
REDIS_PORT=*****
REDIS_PASSWORD=*****



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-mailing\Dockerfile.development ===

# Usa una imagen base de Node (versión LTS recomendada)
FROM node:18-alpine

# Directorio de trabajo en el contenedor
WORKDIR /app

# --- CAPA DE DEPENDENCIAS ---
# Copia archivos de configuración del monorepo necesarios para instalar dependencias
# Estos archivos se encuentran en la raíz del monorepo
COPY package.json yarn.lock turbo.json .yarnrc.yml ./
# Si usas Yarn v4 con la carpeta .yarn, cópiala también:
COPY .yarn .yarn

# Instala todas las dependencias (usando workspaces)
RUN yarn install

# --- CAPA DE CÓDIGO ---
# Copia todo el código del monorepo al contenedor
COPY . .

# Establece el directorio de trabajo al servicio de autenticación
WORKDIR /app/services/service-mailing

# Expone el puerto en el que el servicio escucha (ajústalo según corresponda)
EXPOSE 5002

# Define la variable de entorno para desarrollo
ENV NODE_ENV=development

# Ejecuta el comando de desarrollo definido en el package.json del servicio.
# Por ejemplo, se asume que en services/service-authentication/package.json existe:
# "scripts": { "dev": "ts-node-dev --respawn --transpileOnly src/index.ts" }
CMD ["yarn", "dev"]




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-mailing\package.json ===

{
  "name": "@kikerepo/service-mailing",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn -- src/index.ts --transpileOnly",
    "build": "tsc -p tsconfig.json",
    "clear": "rimraf .turbo dist tsconfig.tsbuildinfo node_modules",
    "uninstall": "rimraf node_modules",
    "lint": "eslint 'src/**/*.ts'"
  },
  "devDependencies": {
    "eslint": "^8.0.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.7.3"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-mailing\tsconfig.json ===

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist"
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-mailing\src\index.ts ===

console.log('Hello from service-mailing!');



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-mailing\__tests__\basic.spec.ts ===

describe('Simple test in Authentication Service', () => {
    it('should pass a basic truthy test', () => {
      expect(true).toBe(true);
    });
  });
  



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-redis-server\.env.development ===

REDIS_PORT=*****
REDIS_PASSWORD=*****



=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-redis-server\docker-compose.yml ===

version: '3.8'
services:
  redis:
    image: redis:latest
    command: ["redis-server", "--requirepass", $(REDIS_PASSWORD)]
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - redis-network

volumes:
  redis-data:

networks:
  redis-network:




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-redis-server\Dockerfile.development ===

FROM redis:7.0-alpine

# Optional: Add custom Redis configuration
# COPY redis.conf /usr/local/etc/redis/redis.conf

# CMD ["redis-server", "/usr/local/etc/redis/redis.conf"]




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-redis-server\package.json ===

{
  "name": "redis-server",
  "version": "1.0.0",
  "description": "Redis server for the monorepo",
  "scripts": {
    "dev": "docker-compose up -d",
    "start": "docker-compose up -d",
    "stop": "docker-compose down",
    "logs": "docker-compose logs -f"
  }
}




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-zoekeeper\.env.development ===

# Port on which the Kafka broker listens inside the container
KAFKA_BROKER_PORT=*****

# For simplicity, you can define hostnames as they will be used inside docker-compose
KAFKA_BROKER_HOST=*****

# Zookeeper settings (if needed)
ZOOKEEPER_CLIENT_PORT=*****




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-zoekeeper\docker-compose.yml ===

version: '3.8'
services:
  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      KAFKA_BROKER_ID: ${KAFKA_BROKER_ID:-1}
      KAFKA_ZOOKEEPER_CONNECT: ${KAFKA_ZOOKEEPER_CONNECT:-zookeeper:2181}
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: ${KAFKA_LISTENER_SECURITY_PROTOCOL_MAP:-PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT}
      KAFKA_ADVERTISED_LISTENERS: ${KAFKA_ADVERTISED_LISTENERS:-PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092}
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: ${KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR:-1}
    ports:
      - "9092:9092"
      - "29092:29092"
    depends_on:
      - zookeeper
    networks:
      - kafka-net

networks:
  kafka-net:
    driver: bridge




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-zoekeeper\Dockerfile.development ===

# Use Node LTS image
FROM node:18-alpine

# Set the working directory
WORKDIR /app

# Copy root-level files (so Yarn workspaces work correctly)
COPY package.json yarn.lock turbo.json .yarnrc.yml ./

# (Optional) If you have a .yarn folder, copy it too
COPY .yarn .yarn

# Install dependencies from the root (Yarn will hoist workspaces if needed)
RUN yarn install --immutable

# Copy all files
COPY . .

# Change directory to the service folder
WORKDIR /app/services/service-kafka

# Expose the port
EXPOSE 3100

# Set environment (development)
ENV NODE_ENV=development

# Start the service
CMD ["yarn", "dev"]




=== FILE: C:\Users\kikelo\Documents\GitHub\yarn-monorepo-ts\services\service-zoekeeper\package.json ===

{
  "name": "service-zoekeeper",
  "version": "1.0.0",
  "description": "zoekeeper server for the monorepo",
  "scripts": {
    "dev": "docker-compose up -d",
    "start": "docker-compose up -d",
    "stop": "docker-compose down",
    "logs": "docker-compose logs -f"
  }
}






=== DIRECTORY TREE ===
Listado de rutas de carpetas
El nmero de serie del volumen es 000000FB EA56:DBC0
C:\USERS\KIKELO\DOCUMENTS\GITHUB\YARN-MONOREPO-TS
   .gitignore
   .yarnrc.yml
   combined.txt
   Dockerfile.development
   jest.config.ts
   MergeAll 2.ps1
   MergeAll.ps1
   package.json
   tsconfig.json
   turbo.json
   yarn.lock
   
+---.vscode
       launch.json
       tasks.json
       
+---.yarn
      install-state.gz
      
   +---releases
           yarn-berry.js
           
+---docker
   +---development
          .env
          docker-compose.yml
          
   +---production
           .env
           docker-compose.yml
           
+---packages
   +---application
      +---user
            package.json
            tsconfig.json
            
         +---src
                index.ts
                
             +---commands
                    index.ts
                    RegisterCommand.ts
                    
             +---errors
                    EmailAlreadyInUseError.ts
                    index.ts
                    
             +---events
                    index.ts
                    UserLoggedInEvent.ts
                    UserRegisteredEvent.ts
                    
             +---handlers
                    index.ts
                    LoginQueryHandler.ts
                    RegisterCommandHandler.ts
                    
             +---mappers
                    index.ts
                    RegisterRequestToRegisterCommandMapper.ts
                    RegisterResultToRegisterResponseMapper.ts
                    
             +---queries
                    index.ts
                    LoginQuery.ts
                    
             +---results
                    index.ts
                    LoginResult.ts
                    RegisterResult.ts
                    
             +---validators
                     index.ts
                     IsPhoneNumber.ts
                     IsStrongPassword.ts
                     
      +---_common
             package.json
             tsconfig.json
             
          +---src
                 index.ts
                 Result.ts
                 
              +---behaviours
                     AuthorizationBehaviour.ts
                     index.ts
                     ValidationBehaviour.ts
                     
              +---enums
              +---middleware
                      ErrorHandlerMiddleware.ts
                      index.ts
                      ValidationMiddleware.ts
                      
   +---contracts
      +---user
            package.json
            tsconfig.json
            
         +---src
                index.ts
                
             +---requests
                    ChangePasswordRequest.ts
                    ForgotPasswordRequest.ts
                    index.ts
                    LoginRequest.ts
                    RegisterRequest.ts
                    
             +---responses
                     ChangePasswordResponse.ts
                     ForgotPaswordResponse.ts
                     index.ts
                     LoginResponse.ts
                     RegisterResponse.ts
                     
      +---_common
             package.json
             tsconfig.json
             
          +---src
                 index.ts
                 
              +---errors
                     BaseError.ts
                     ConflictError.ts
                     index.ts
                     InternalError.ts
                     NotFoundError.ts
                     ValidationError.ts
                     
              +---responses
   +---domain
      +---user
            package.json
            tsconfig.json
            
         +---src
                index.ts
                
             +---entities
                    index.ts
                    User.ts
                    
             +---events
                    index.ts
                    UserCreatedEvent.ts
                    
             +---interfaces
                    IHashingService.ts
                    index.ts
                    IUserRepository.ts
                    
             +---value-objects
                     Email.ts
                     HashedPassword.ts
                     index.ts
                     InputPassword.ts
                     Phone.ts
                     UserId.ts
                     
      +---_common
             package.json
             tsconfig.json
             
          +---src
                 AggregateRoot.ts
                 AggregateRootId.ts
                 DomainError.ts
                 DomainEvent.ts
                 Entity.ts
                 index.ts
                 ValueObject.ts
                 
              +---interfaces
                     IEntityId.ts
                     IErrorResponse.ts
                     index.ts
                     
              +---value-objects
                      CreationDate.ts
                      DeletionDate.ts
                      index.ts
                      
   +---infrastructure
      +---user
            package.json
            tsconfig.json
            
         +---src
                index.ts
                
             +---persistance
                    index.ts
                    UserDatabase.ts
                    UserRepository.ts
                    
             +---services
                     Argon2HashingService.ts
                     index.ts
                     
      +---_common
             package.json
             tsconfig.json
             
          +---src
                 index.ts
                 
              +---authentication
                     authenticationToken.ts
                     index.ts
                     
              +---logging
                     index.ts
                     logger.ts
                     
              +---middleware
                      AuthenticationMiddleware.ts
                      index.ts
                      RequestLoggerMiddleware.ts
                      
   +---utils
       +---env
             index.ts
             package.json
             tsconfig.json
             
          +---src
                 index.ts
                 requireEnv.ts
                 
          +---__tests__
                  basic.spec.ts
                  
       +---kafka-client
             jest.config.ts
             package.json
             tsconfig.json
             
          +---src
                 index.ts
                 KafkaClient.ts
                 
          +---__tests__
                  kafkaclient.spec.ts
                  
       +---redis-client
             jest.config.ts
             package.json
             tsconfig.json
             
          +---src
                 index.ts
                 RedisClient.ts
                 
          +---__tests__
                  redisclient.spec.ts
                  
       +---uuid6
              index.ts
              package.json
              tsconfig.json
              
           +---src
                  index.ts
                  uuid6.ts
                  
           +---__tests__
                   basic.spec.ts
                   
+---services
    +---service-authentication
          .env
          .env.development
          Dockerfile.development
          jest.config.ts
          package.json
          tsconfig.json
          
       +---prisma
             schema.prisma
             
          +---migrations
                 migration_lock.toml
                 
              +---20250120232605_init
                     migration.sql
                     
              +---20250122200614_add_deleted
                      migration.sql
                      
       +---src
             index.ts
             
          +---bootstrap
                 container.ts
                 index.ts
                 
          +---controllers
                 index.ts
                 UserController.ts
                 
          +---routes
                 index.ts
                 UserRoutes.ts
                 
              +---v1
       +---__http__
              login.http
              register.http
              
       +---__tests__
               basic.spec.ts
               
    +---service-kafka
           .env.development
           docker-compose.yml
           Dockerfile.development
           package.json
           
    +---service-mailing
          .env.development
          Dockerfile.development
          package.json
          tsconfig.json
          
       +---src
              index.ts
              
       +---__tests__
               basic.spec.ts
               
    +---service-redis-server
           .env.development
           docker-compose.yml
           Dockerfile.development
           package.json
           
    +---service-zoekeeper
            .env.development
            docker-compose.yml
            Dockerfile.development
            package.json
            
